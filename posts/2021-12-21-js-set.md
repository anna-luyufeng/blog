---
title: "[JS] Map èˆ‡ Set é›†åˆ"
layout: layouts/post.njk

---

# Map

 a collection of keyed data items èˆ‡ `Object` å¾ˆé¡žä¼¼

## `Object` vs `Map`

- `key` éµçš„é¡žåž‹ï¼š`Map` å¯ä»¥æ˜¯**ä»»ä½•é¡žåž‹çš„å€¼**ï¼Œ`Object`çš„ `key` å¿…é ˆæ˜¯ `String` æˆ–æ˜¯ `Symbol`
- éµçš„é †åºï¼š `Map` æ˜¯ä»¥æ’å…¥çš„é †åºåšæŽ’åºï¼ŒES 6 å¾Œ `Object` åªæœ‰ `String` é¡žåž‹çš„éµä¿ç•™æ’å…¥çš„é †åº
- iterable å¯è¿­ä»£ï¼š`Map` å¯ä»¥ç›´æŽ¥ iterateï¼Œ`Object` éœ€è¦é€éŽå…¶ä»–æ–¹æ³•å–å¾—éµå¾Œè¨ˆç®—
- è‹¥è¦é »ç¹å¢žåˆªéµå€¼çš„æ“ä½œï¼Œ`Map` æ•ˆèƒ½æœƒæ¯” `Object` å¥½

### é©åˆç”¨ `Object` çš„æƒ…æ³

- WIP

```js
let map = new Map();

// stores the value by the key, returns the map itself
map.set('1', 'str1');   // a string key
map.set(1, 'num1');     // a numeric key
map.set(true, 'bool1'); // a boolean key
map.set({ name: "Anna"}, 'object1'); // ðŸŒŸ an object key

// can chain the map.set(key, value) calls
map.set('1', 'str1')
  .set(1, 'num1')
  .set(true, 'bool1')
  .set({ name: "Anna"}, 'object1');

// remember the regular Object? it would convert keys to string
// Map keeps the type, so these two are different:
console.log( map.get(1)   ); // 'num1'
console.log( map.get('1') ); // 'str1'
console.log( map.get('2') ); // undefined

console.log( map.size ); // 3

// if the key exists
console.log( map.has('1')); // true 
console.log( map.has('2')); // false

// delete the key
 map.delete('1');
```

## âš ï¸ `map[key]` ä¸æ˜¯æ­£ç¢ºä½¿ç”¨ `Map` çš„å§¿å‹¢

 `Map` çš„ç›¸é—œæ–¹æ³•æœƒä¸é©ç”¨ï¼Œå¦‚ `has()` 



## Map æ˜¯å¦‚ä½•æ¯”å° `keys` æ˜¯å¦ç›¸ç­‰çš„ï¼Ÿ

- åŸºæ–¼ [sameValueZero](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#é›¶å€¼ç›¸ç­‰) ç®—æ³•
- é™¤äº† `NaN` ç­‰æ–¼ `NaN` å…¶ä»–çš„å€¼æ ¹æ“š strict equality  `===` åˆ¤æ–·æ˜¯å¦ç›¸ç­‰ï¼ˆ`NaN`!== `NaN`ï¼‰
- åœ¨ ES 6 å‰ï¼Œ`-0` ä¸ç­‰æ–¼ `0`

## Iteration over Map

`for...of` or `forEach`

```js
let recipeMap = new Map([
  ['cucumber', 500],
  ['tomatoes', 350],
  ['onion',    50]
]);

// iterate over keys (vegetables)
for (let vegetable of recipeMap.keys()) {
  console.log(vegetable); // cucumber, tomatoes, onion
}

// iterate over values (amounts)
for (let amount of recipeMap.values()) {
  console.log(amount); // 500, 350, 50
}

// iterate over [key, value] entries
for (let entry of recipeMap) { // ðŸŒŸ the same as of recipeMap.entries()
  console.log(entry); // cucumber,500 (and so on)
}

// runs the function for each (key, value) pair
recipeMap.forEach( (value, key, map) => {
  console.log(`${key}: ${value}`); // cucumber: 500 etc
});
```

## Array & Map

```js
// Array â†’ Map
// array of [key, value] pairs
const keyValueArray = [
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
];
let map = new Map(keyValueArray);

console.log( map.get('1') ); // str1

// Map â†’ Array
console.log(Array.from(map)); // same as keyValueArray
console.log([...map]);

// only keys
console.log(Array.from(map.keys())); // ['1', 1, true]
```

Array -> Map

```js
const valueArray = ['apple', 'blueberry', 'lemon'];

const map = new Map();

valueArray.forEach((value, valueIndex) => {
 map.set( value, valueIndex);
});
```



## Object & Map

```js
// Object â†’ Map : Object.entries(obj)
let obj = {
  name: "Anna",
  age: 18
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // Anna

// Array -> Object
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// now prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2


// Map -> Object
let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // make a plain object (*)
// => let obj = Object.fromEntries(map);

// done!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
```



## åˆä½µ Map

```js
let firstMap = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

let secondMap = new Map([
  [1, 'uno'],
  [2, 'dos']
]);

// è‹¥æœ‰é‡è¤‡çš„ keyï¼Œå¾Œé¢æœƒè¦†è“‹å‰é¢çš„å€¼ï¼Œä¹Ÿå¯ä»¥è·Ÿ Array åˆä½µ
let merged = new Map([...firstMap, ...secondMap, [1, 'eins']]); 
// Map { 1 => 'eins', 2 => 'dos', 3 => 'three' }
```



## ä»€éº¼æ˜¯é›†åˆï¼Ÿ

ä¸€çµ„**ç„¡é †åº**ä¸”**ä¸é‡è¤‡**çš„å…ƒç´ 

â€œset of valuesâ€ (without keys), where each value may occur only once

```js
// å»ºç«‹ Set
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// å°‡å…ƒç´ æ”¾é€² Set
set.add(john); // Set { { name: "John" } }
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// å¾ž Set ä¸­ç§»é™¤å…ƒç´ 
set.delete(mary);

// æŸ¥çœ‹ Set ä¸­æœ‰å¤šå°‘å…ƒç´ 
console.log(set.size); // 2

// æª¢æŸ¥ Set ä¸­æ˜¯å¦æœ‰åŒ…å«æŸå…ƒç´ 
set.has(john); // true
set.has(mary); // false

// æ¸…ç©º Set
set.clear();
```

> [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) @MDN
>
> [é›†åˆï¼ˆæ•¸å­¸ï¼‰](https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E6%95%B0%E5%AD%A6)) @ç¶­åŸºç™¾ç§‘

## Iteration over Set

`for...of` or `forEach`

```js
let set = new Set([1,2,3]);

for (let value of set) console.log(item) 

// valueAgain è·Ÿ value ç›¸åŒ
set.forEach((value, valueAgain, set) => {
  console.log(value);
});
```

- `set.keys()`
- `set.values()`
- `set.entries()`

```js
const set1 = new Set();

set1.add(1);
set1.add(5);
set1.add('text');

for (let item of set1) console.log(item)
for (let item of set1.keys()) console.log(item)
for (let item of set1.values()) console.log(item)
set1.forEach(function(item) {
  console.log(item)
})

// Set è½‰æˆ Array
const array = Array.from(set1);
const array = [...set1]

// Array è½‰æˆ Set
const set2 = new Set([1,2,3,4]);

// å–äº¤é›†ï¼ˆintersectï¼‰
const intersection = new Set([...set1].filter(x => set2.has(x)))

// å–å·®é›†ï¼ˆdifferenceï¼‰
const difference = new Set([...set1].filter(x => !set2.has(x)))
```



## Set èˆ‡ Map ä½¿ç”¨æƒ…å¢ƒ

ES6 ä¸­å¦‚æžœï¼š

- å¸Œæœ›ã€Œé™£åˆ—ï¼ˆArrayï¼‰ã€çš„**å…ƒç´ **ä¸æœƒé‡è¤‡ï¼Œå¯ä»¥ä½¿ç”¨ `Set`
- å¸Œæœ›ã€Œç‰©ä»¶ï¼ˆObjectï¼‰ã€çš„**éµ**ä¸æœƒé‡è¤‡ï¼Œå‰‡å¯ä»¥ä½¿ç”¨ `Map`



## å¯¦éš›ç¯„ä¾‹

### è‹¥å…ƒç´ æœªè¢«é¸æ“‡ï¼Œå‰‡é¸ä¹‹ï¼›è‹¥å·²é¸æ“‡ï¼Œå‰‡å°‡ä¹‹ç§»é™¤

```js
const [selectedTagIds, setSelectedTagIds] = useState(new Set());

const onClickTag = (id) => () => {
	const copiedSelectedTagIds = new Set(selectedTags);
	if (!copiedSelectedTags.delete(id)){
		copiedSelectedTags.add(id);
	}
  setSelectedTagIds(copiedSelectedTagIds);
}
```

